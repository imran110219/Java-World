# জাভা মেমোরি ম্যানেজমেন্ট          
জাভাতে মেমোরি ম্যানেজমেন্ট হল এমন একটা প্রসেস যার মাধ্যমে কোন অবজেক্ট  মেমোরিতে একটি জায়গা নেয় এবং কাজ শেষে আবার স্বয়ংক্রিয়ভাবে ধ্বংস হয়ে যায়। জাভা নিজে এই প্রসেসটা অটোমেটিক ভাবে করে থাকে। জাভার এই স্বয়ংক্রিয় মেমোরি ম্যানেজমেন্ট সিস্টেম কে বলা হয়  গারবেজ কালেক্টর 'garbage collector'।  অন্য অনেক ল্যাংগুয়েজে ম্যানুয়ালি অবজেক্ট বানাতে হয় এবং কাজ শেষে ধংস বা destroy করে দিতে হয়। কিন্তু একজন জাভা ডেভেলপারের জাভা মেমোরি ম্যানেজমেন্ট সম্পর্কে জানা উচিত।  
জাভাতে মেমোরি প্রধানত দুই প্রকারঃ      
১. স্ট্যাক (Stack)    
২. হিপ (Heap)    

**স্ট্যাক (Stack)**       
স্ট্যাক মেমোরিতে রাখা হয় হিপ মেমোরিতে থাকা কোন অবজেক্টের রেফারেন্স এবং জাভার ভ্যালু টাইপ যেটা জাভাতে primitive হিসেবে পরিচিত যেমনঃ int, boolean ইত্যাদি। স্ট্যাক হল "Last In First Out"। যখন কোন নতুন মেথড কল হবে স্ট্যাক এর ভেতরে নতুন একটা ব্লক তৈরি হবে যার ভেতরে ওই মেথডের কিছু ভ্যালু থাকবে যেমন primitive variables আর অবজেক্টের রেফারেন্স। যখন মেথডের কাজ শেষ হয়ে যাবে তখন স্ট্যাক ওই ভ্যালু টা মুছে যাবে। 

**হিপ (Heap)**    
স্ট্যাক মেমোরিতে যার রেফারেন্স থাকবে সেই অবজেক্টের সব কিছু থাকবে হিপ মেমোরিতে।   
```
StringBuilder builder = new StringBuilder();
```              
এই new কি ওয়ার্ড ব্যবহারের মাধ্যমে আমরা হিপে অবজেক্টের জন্য যা জায়গা দরকার হয় সেই পরিমান মেমোরি পাই। আমরা StringBuilder অবজেক্ট মেমোরিতে তৈরি করেছি এবগ এইটার রেফারেন্স নাম builder যেটা স্ট্যাক মেমোরিতে সেভ আছে।  প্রতিটা JVM প্রসেসে একটাই হিপ মেমোরি থাকে। হিপ নিজেই কিছু অংশে বিভক্ত থাকে garbage collection প্রসেস চালানোর জন্য। এটার সাইজ নির্দিষ্ট করা থাকে না এটা নির্ভর করে মেশিনের উপর। 


**রেফারেন্স টাইপ (Reference Type)**   
হিপ মেমোরিতে যেই অবজেক্ট থাকে সেগুলোর রেফারেন্স থাকে স্ট্যাক মেমোরিতে। এই রেফারেন্স বিভিন্ন কাজের ধরন অনুসারে বিভিন্ন ধরনের হয়ে থাকে। রেফারেন্স ৪ ধরনের হয়। সেগুলো হলঃ         
**১. স্ট্রং রেফারেন্স (Strong Reference)**       
সবচেয়ে প্রচলিত রেফারেন্স টাইপ হল এইটা। উপরের উদাহরনে  StringBuilder আছে এইটা হল স্ট্রং রেফারেন্স। এই অবজেক্ট গারবেজ হিসেবে যায় না যতক্ষন পর্যন্ত এইটার উপর স্ট্রং রেফারেন্স পয়েন্ট করে থাকে।       

**২. উইক রেফারেন্স (Weak Reference)**      
উইক রেফারেন্স যখন হিপে থাকা অবজেক্টের উপর পয়েন্ট করা থাকে তাহলে নেক্সট গারবেজ কালেকশান প্রসেসে সেটা ডিলিট হয়ে যায়।       
```
WeakReference<StringBuilder> reference = new WeakReference<>(new StringBuilder());
```

**৩. সফট রেফারেন্স (Soft Reference)**      
এই ধরনের রেফারেন্স ব্যবহার করা মেমোরি সেনসিটিভ ক্ষেত্রে, যখন অ্যাপ্লিকেশান মেমোরি স্পেস কমে যায় তখন এর গারবেজ কালেক্ট হয়। এইটা কিছু উইক রেফারেন্সের মতই। কিন্তু পার্থক্য হছে এই রেফারেন্সের অবজেক্ট গুলো তখনই গারবেজ হিসেবে কালেক্ট হয় যখন ক্রিটিকালি আমাদের মেমোরি ফাকা করার দরকার পড়ে। যখন জাভা প্রোগ্রাম OutOfMemoryError দেয় তার আগে সকল সফট রেফারেন্স অবজেক্ট ক্লিয়ার হয়ে যায়।     
```
SoftReference<StringBuilder> reference = new SoftReference<>(new StringBuilder());
```

**৪. ফ্যান্টম রেফারেন্স (Phantom Reference)**    

**গারবেজ কালেকশান যেভাবে কাজ করে**       
As discussed earlier, depending on the type of reference that a variable from the stack holds to an object from the heap, at a certain point in time, that object becomes eligible for the garbage collector.
   
 


https://dzone.com/articles/java-memory-management      
https://medium.com/mindorks/java-memory-management-6e7ccafafcc1

